-- Gotta figure out how to compile votes--Attempt Made
-- Gotta figure out how to write on chain code to compare votes--Attempt Made
-- Gotta figure out what to put on-chain vs. off--Attempt Made
-- Should we lift bounty char and intel char to the ledger????  Maybe not.
-- Gotta figure out how to do % payouts on curation, blacklisting, and intel provision
-- Gotta figure out how to do curation and blacklisting staking (like in Marlowe)


import qualified Language.PlutusTx            as PlutusTx
import qualified Language.PlutusTx.Prelude    as P
import qualified Language.PlutusTx.Builtins   as Builtins
import qualified Data.ByteString.Lazy.Char8   as BSLC
import           Ledger
import           Ledger.Validation
import           Wallet
import           Playground.Contract


jbValidator :: ValidatorScript
jbValidator = ValidatorScript $ Ledger.fromCompiledCode $$(PlutusTx.compile
  [||
   \(curationVote :: [int]) (blackListVote :: [int]) (p :: PendingTx') ->
    let
    
      voteCarries :: int -> bool
      voteCarries n = = $$(P.foldr) (\i acc -> $$(P.or) acc (Builtins.greaterThanInteger i n)) False
--need to fix this line to do the addition of all the votes before it calls greaterThanInteger against 0
--where do I put the 0?  what does "/i acc" do?   What do "i" and "n" do after greaterThanInteger?  Should 0 replace them?

      curationVoteCarries :: Bool
      curationVoteCarries = $$(P.foldr) (\i acc -> $$(P.and) acc (voteCarries i)) True curationVote

      blackListVoteCarries :: Bool
      blackListVoteCarries = $$(P.foldr) (\i acc -> $$(P.and) acc (voteCarries i)) True blackListVote

    in

      if curationVoteCarries && blackListVoteCarries
      then ()
      else $$(P.error) ($$(P.traceH) "Sorry.  Insufficient Intel." ())
   ||])

scAddress :: Address'
scAddress = Ledger.scriptAddress jbValidator

curationVoteCheck :: Int -> MockWallet ()
curationVoteCheck num = if num /= 1 or (-1) then throwOtherError "You may only vote 1 for Winning Intel or -1 for Insufficient Intel."
  else pure ()
  

blackListVoteCheck :: Int -> MockWallet ()
blackListVoteCheck num = if num /= 1 or (-1) then throwOtherError "You may only vote 1 for a Good Bounty or -1 for a Blacklisted Bounty."
  else pure ()
 
postBounty :: [char] -> MockWallet ()
postBounty char prize = do
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show char
  in payToScript_ scAddress prize $ DataScript $ Ledger.lifted hashedChar
  register closeBountyTrigger (closeBountyHandler hashedChar)

postIntel :: [char] -> MockWallet ()
postIntel char = do
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show char
  in collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted hashedChar

curationVote :: Int -> MockWallet ()
curationVote num = do
  curationVoteCheck num
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show num
  collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted num

blackListVote :: Int -> MockWallet ()
blackListVote num = do
  blackListVoteCheck num
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show num
  collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted num

watchSCAddress :: MockWallet ()
watchSCAddress = startWatching scAddress

closeBountyTrigger :: EventTrigger
closeBountyTrigger = andT
  (fundsAtAddressT scAddress $ GEQ 1)
  (blockHeightT (Interval (Height 100) (Height 101)))

closeBountyHandler :: ByteString -> EventHandler MockWallet
closeBountyHandler hashedChar = EventHandler (\_ -> do
 logMsg "No Winning Intel was provided in time."
 logMsg "Ending Bounty and withdrawing money from SC."
 collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted hashedChar)

$(mkFunction 'postBounty)
$(mkFunction 'postIntel)
$(mkFunction 'watchSCAddress)
$(mkFunction 'curationVote)
$(mkFunction 'blackListVote)


