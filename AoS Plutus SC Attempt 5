--Two contracts Below



{-FIRST CONTRACT-}
import qualified Language.PlutusTx            as PlutusTx
import qualified Language.PlutusTx.Prelude    as P
import qualified Language.PlutusTx.Builtins   as Builtins
import qualified Data.ByteString.Lazy.Char8   as BSLC
import           Ledger
import           Ledger.Validation
import           Wallet
import           Playground.Contract


bountyValidator :: ValidatorScript
bountyValidator = ValidatorScript $ Ledger.fromCompiledCode $$(PlutusTx.compile
  [||
   \(curationAndBlacklistVote :: [int]) (postBounty :: [char]) (p :: PendingTx') ->
    let
      
      curationAndBlacklistVoteTally :: int -> bool
      curationAndBlacklistVoteTally n = = $$(P.foldr) (\i acc -> Builtins.greaterThanInteger (i+acc) 0) false curationAndBlacklistVote
      --foldr probably doesn't actually accumulate the votes like this from all the individual addresses trying to use the RedeemerScript to vote.
      --how do I collect all the votes together into a [int]?
      --”$$(P.” is just how you call Prelude functions (e.g. in this case “foldr”)
      --”\” denotes a lambda (i.e. just a function without a name we’ll only use once)
      --”i” is just the argument we’re passing to the nameless function (in this case, curationVote)
      --”greatherThanInteger i 0” just checks if “i” is greater than “0”.
      --”acc” is just an accumulator (explained in “Folds and Horses” chapter in Learn you a Haskell)
      --the 0 after the parenthetical is the starting point for the accumulator
      
      curationAndBlacklistVoteCarries :: Bool
      curationAndBlacklistVoteCarries = $$(P.foldr) (\i acc -> $$(P.and) acc (curationAndBlacklistVoteTally i)) True curationAndBlacklistVote

    in

      if curationAndBlacklistVoteCarries
      then ()
      else $$(P.error) ($$(P.traceH) "Sorry, insufficient voting." ())
   ||])
 
scAddress :: Address'
scAddress = Ledger.scriptAddress bountyValidator

curationVoteCheck :: Int -> MockWallet ()
curationVoteCheck num = if num /= 1 or (-1) or (-100) then throwOtherError "You may only vote 1 for Winning Intel, -1 for Insufficient Intel,or -100 for a Blacklisted Bounty."
else pure ()
 
postBounty :: [char] -> Value -> MockWallet ()
postBounty char prize = do
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show char
  in payToScript_ scAddress prize $ DataScript $ Ledger.lifted hashedChar
  register closeBountyTrigger (closeBountyHandler hashedChar)

curationAndBlacklistVote :: Int -> MockWallet ()
curationAndBlacklistVote num = do
  curationVoteCheck num
  let hashedNum = plcSHA2_256 $ BSLC.pack $ show num
  collectFromScript bountyValidator $ RedeemerScript $ Ledger.lifted hashedNum
  --in the two contract structure, would need a way to collectFromScript to a different address than the address using the RedeemerScript
  
watchSCAddress :: MockWallet ()
watchSCAddress = startWatching scAddress

closeBountyTrigger :: EventTrigger
closeBountyTrigger = andT
  (fundsAtAddressT scAddress $ GEQ 1)
  (blockHeightT (Interval (Height 100) (Height 101)))

closeBountyHandler :: ByteString -> EventHandler MockWallet
closeBountyHandler hashedChar = EventHandler (\_ -> do
    logMsg "Not enough votes provided in time."
    logMsg "Ending Bounty and withdrawing money from SC."
    collectFromScript bountyValidator $ RedeemerScript $ Ledger.lifted hashedChar

$(mkFunction 'postBounty)
$(mkFunction 'watchSCAddress)
$(mkFunction 'curationAndBlackListVote)
   
   
   
{-SECOND CONTRACT-}
import qualified Language.PlutusTx            as PlutusTx
import qualified Language.PlutusTx.Prelude    as P
import qualified Language.PlutusTx.Builtins   as Builtins
import qualified Data.ByteString.Lazy.Char8   as BSLC
import           Ledger
import           Ledger.Validation
import           Wallet
import           Playground.Contract


bountyValidator :: ValidatorScript
bountyValidator = ValidatorScript $ Ledger.fromCompiledCode $$(PlutusTx.compile
  [||
   \(postIntel :: [int]) (postBounty :: [int]) (p :: PendingTx') ->
    let
    
      curationVoteTally :: int -> bool
      curationVoteTally n = = $$(P.foldr) (\i acc -> Builtins.greaterThanInteger (i+acc) 0) 0 curationVote



      blackListVoteTally :: int -> bool
      blackListVoteTally n = = $$(P.foldr) (\i acc -> Builtins.greaterThanInteger (i+acc) 0)) 0 blackListVote
--whatever you do to curationVote Tally, do to blackListVoteTally


      curationVoteCarries :: Bool
      curationVoteCarries = $$(P.foldr) (\i acc -> $$(P.and) acc (curationVoteTally i)) True curationVote

      blackListVoteCarries :: Bool
      blackListVoteCarries = $$(P.foldr) (\i acc -> $$(P.and) acc (blackListvoteTally i)) True blackListVote

    in

      if curationVoteCarries && blackListVoteCarries
      then ()
      else $$(P.error) ($$(P.traceH) "Sorry.  Insufficient Intel." ())
   ||])

scAddress :: Address'
scAddress = Ledger.scriptAddress jbValidator

curationVoteCheck :: Int -> MockWallet ()
curationVoteCheck num = if num /= 1 or (-1) then throwOtherError "You may only vote 1 for Winning Intel or -1 for Insufficient Intel."
  else pure ()
  

blackListVoteCheck :: Int -> MockWallet ()
blackListVoteCheck num = if num /= 1 or (-1) then throwOtherError "You may only vote 1 for a Good Bounty or -1 for a Blacklisted Bounty."
  else pure ()
 
postBounty :: [char] -> Value -> MockWallet ()
postBounty char prize = do
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show char
  in payToScript_ scAddress prize $ DataScript $ Ledger.lifted hashedCharBounty
  register closeBountyTrigger (closeBountyHandler hashedChar)

postIntel :: [char] -> MockWallet ()
postIntel char = do
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show char
  in collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted hashedCharIntel

curationVote :: Int -> MockWallet ()
curationVote numCuration = do
  curationVoteCheck num
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show num
  collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted numCuration

blackListVote :: Int -> MockWallet ()
blackListVote num = do
  blackListVoteCheck num
  let hashedChar = plcSHA2_256 $ BSLC.pack $ show num
  collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted numBlackList

watchSCAddress :: MockWallet ()
watchSCAddress = startWatching scAddress

closeBountyTrigger :: EventTrigger
closeBountyTrigger = andT
  (fundsAtAddressT scAddress $ GEQ 1)
  (blockHeightT (Interval (Height 100) (Height 101)))

closeBountyHandler :: ByteString -> EventHandler MockWallet
closeBountyHandler hashedChar = EventHandler (\_ -> do
 logMsg "No Winning Intel was provided in time."
 logMsg "Ending Bounty and withdrawing money from SC."
 collectFromScript jbValidator $ RedeemerScript $ Ledger.lifted hashedChar

$(mkFunction 'postBounty)
$(mkFunction 'postIntel)
$(mkFunction 'watchSCAddress)
$(mkFunction 'curationVote)
$(mkFunction 'blackListVote)
